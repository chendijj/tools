<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠŸèƒ½å•æ®åˆ†ç±»å·¥å…· - Tools Collection</title>
    <!-- å¼•å…¥ä¸»é¢˜æ ·å¼ -->
    <link rel="stylesheet" href="../shared/theme.css">
</head>
<body>
    <div class="min-h-screen" style="background-color: var(--bg-primary)">
        <div class="app-container">
            <!-- æ ‡é¢˜æ  -->
            <header class="header">
                <div class="title-bar">
                    <div class="title-left">
                        <span class="icon">ğŸ“‹</span>
                        <h1>åŠŸèƒ½å•æ®åˆ†ç±»å·¥å…·</h1>
                    </div>
                    <div class="theme-toggle">
                        <button onclick="toggleTheme()" title="åˆ‡æ¢ä¸»é¢˜">
                            <span id="themeIcon">ğŸŒ™</span>
                        </button>
                    </div>
                </div>
            </header>

            <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
            <main style="padding: 20px">
                <div class="animate-fadeIn" style="display: flex; flex-direction: column; gap: 20px">

                    <!-- å·¥å…·æ  -->
                    <div class="toolbar">
                        <div class="toolbar-content">
                            <div class="toolbar-group">
                                <button onclick="processDocument()" class="tool-button primary">
                                    <span>ğŸ”„</span>
                                    å¤„ç†æ–‡æ¡£
                                </button>
                                <button onclick="loadExample(); processDocument();" class="tool-button">
                                    <span>ğŸ“Š</span>
                                    åŠ è½½ç¤ºä¾‹
                                </button>
                                <button onclick="toggleRulesPanel()" class="tool-button">
                                    <span>âš™ï¸</span>
                                    åˆ†ç±»è§„åˆ™
                                </button>
                            </div>
                            <div class="toolbar-group">
                                <button onclick="copyResult()" class="tool-button success">
                                    <span>ğŸ“‹</span>
                                    å¤åˆ¶ç»“æœ
                                </button>
                                <button onclick="clearAll()" class="tool-button danger">
                                    <span>ğŸ—‘ï¸</span>
                                    æ¸…ç©º
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- è‡ªå®šä¹‰åˆ†ç±»è§„åˆ™é¢æ¿ -->
                    <div class="card" id="rulesPanel" style="display: none;">
                        <div class="card-header">
                            <h3 class="card-title">
                                <span>âš™ï¸</span>
                                è‡ªå®šä¹‰åˆ†ç±»è§„åˆ™
                            </h3>
                        </div>
                        <div class="card-body">
                            <div style="display: flex; flex-direction: column; gap: 15px;">
                                
                                <!-- æ·»åŠ æ–°è§„åˆ™åŒºåŸŸ -->
                                <div style="display: flex; gap: 10px; align-items: end;">
                                    <div style="flex: 1;">
                                        <label style="display: block; margin-bottom: 5px; color: var(--text-secondary); font-size: 14px;">ç±»åˆ«åç§°</label>
                                        <input type="text" id="newCategory" class="form-control" placeholder="ä¾‹å¦‚ï¼šUIè®¾è®¡" style="height: 40px;">
                                    </div>
                                    <div style="flex: 2;">
                                        <label style="display: block; margin-bottom: 5px; color: var(--text-secondary); font-size: 14px;">å…³é”®è¯ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰</label>
                                        <input type="text" id="newKeywords" class="form-control" placeholder="ä¾‹å¦‚ï¼šç•Œé¢,UI,å‰ç«¯,é¡µé¢" style="height: 40px;">
                                    </div>
                                    <button onclick="addCustomRule()" class="tool-button primary" style="height: 40px;">
                                        <span>â•</span>
                                        æ·»åŠ è§„åˆ™
                                    </button>
                                </div>

                                <!-- ç°æœ‰è§„åˆ™åˆ—è¡¨ -->
                                <div>
                                    <h4 style="margin: 0 0 10px 0; color: var(--text-primary); font-size: 16px;">å½“å‰åˆ†ç±»è§„åˆ™</h4>
                                    <div id="rulesList" style="display: flex; flex-direction: column; gap: 8px; max-height: 300px; overflow-y: auto;">
                                        <!-- è§„åˆ™åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                                    </div>
                                </div>

                                <!-- æ“ä½œæŒ‰é’®åŒºåŸŸ -->
                                <div style="display: flex; gap: 10px; justify-content: flex-end; border-top: 1px solid var(--border-color); padding-top: 15px;">
                                    <button onclick="resetToDefault()" class="tool-button" style="background-color: var(--warning-color); color: white; border-color: var(--warning-color);">
                                        <span>ğŸ”„</span>
                                        æ¢å¤é»˜è®¤
                                    </button>
                                    <button onclick="exportRules()" class="tool-button success">
                                        <span>ğŸ“¤</span>
                                        å¯¼å‡ºè§„åˆ™
                                    </button>
                                    <button onclick="document.getElementById('importFile').click()" class="tool-button success">
                                        <span>ğŸ“¥</span>
                                        å¯¼å…¥è§„åˆ™
                                    </button>
                                    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importRules(this)">
                                </div>

                            </div>
                        </div>
                    </div>

                    <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
                    <div class="input-output-grid">
                        <!-- è¾“å…¥åŒºåŸŸ -->
                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">
                                    <span>ğŸ“</span>
                                    è¾“å…¥æ–‡æ¡£
                                </h3>
                            </div>
                            <div class="card-body">
                                <textarea
                                    id="input"
                                    class="form-control monospace"
                                    style="height: 400px;"
                                    placeholder="è¯·åœ¨æ­¤å¤„ç²˜è´´æ‚¨çš„åŠŸèƒ½å•æ®æ–‡æœ¬...

æ”¯æŒæ ¼å¼ï¼š
ã€ç±»åˆ«ã€‘åŠŸèƒ½åç§°
æˆ–è€…
æ™®é€šåŠŸèƒ½åç§°ï¼ˆå°†å½’ç±»åˆ°"å…¶ä»–"ï¼‰"
                                ></textarea>
                            </div>
                        </div>

                        <!-- è¾“å‡ºåŒºåŸŸ -->
                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title">
                                    <span>ğŸ“Š</span>
                                    åˆ†ç±»ç»“æœ
                                </h3>
                            </div>
                            <div class="card-body">
                                <textarea
                                    id="output"
                                    class="form-control monospace"
                                    style="height: 400px;"
                                    readonly
                                    placeholder="å¤„ç†åçš„åˆ†ç±»ç»“æœå°†åœ¨æ­¤æ˜¾ç¤º..."
                                ></textarea>
                            </div>
                        </div>
                    </div>

                    <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                    <div class="stats" id="stats" style="display: none;">
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-number" id="totalCategories">0</div>
                                <div class="stat-label">ç±»åˆ«æ•°é‡</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-number" id="totalFunctions">0</div>
                                <div class="stat-label">åŠŸèƒ½æ€»æ•°</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-number" id="categorizedFunctions">0</div>
                                <div class="stat-label">å·²åˆ†ç±»åŠŸèƒ½</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-number" id="otherFunctions">0</div>
                                <div class="stat-label">å…¶ä»–åŠŸèƒ½</div>
                            </div>
                        </div>
                    </div>

                </div>
            </main>

        </div>
    </div>

    <!-- Toasté€šçŸ¥ -->
    <div class="toast" id="toast"></div>

    <!-- å¼•å…¥ä¸»é¢˜è„šæœ¬ -->
    <script src="../shared/theme.js"></script>
    
    <!-- å·¥å…·ä¸“æœ‰è„šæœ¬ -->
    <script>
        // è‡ªå®šä¹‰åˆ†ç±»è§„åˆ™ç®¡ç†
        class CustomRulesManager {
            constructor() {
                this.defaultRules = {
                    'è‹±é›„': ['è‹±é›„', 'è§’è‰²', 'äººç‰©'],
                    'è£…å¤‡': ['è£…å¤‡', 'æ­¦å™¨', 'é“å…·', 'ç‰©å“'],
                    'å…³å¡': ['å…³å¡', 'å‰¯æœ¬', 'æˆ˜æ–—', 'boss', 'pve', 'æŒ‘æˆ˜'],
                    'ç³»ç»Ÿ': ['ç³»ç»Ÿ', 'åŠŸèƒ½', 'è®¾ç½®', 'é…ç½®'],
                    'GM': ['gm', 'ç®¡ç†', 'åå°', 'å·¥å…·'],
                    'æ¼”ä¹ ': ['æ¼”ä¹ ', 'ç«æŠ€', 'pvp', 'å¯¹æˆ˜'],
                    'å»ºç­‘': ['å»ºç­‘', 'å‡çº§', 'å»ºé€ '],
                    'æ€ªç‰©': ['æ€ªç‰©', 'é‡æ€ª', 'æ•Œäºº']
                };
                this.customRules = this.loadRules();
            }

            // åŠ è½½è§„åˆ™ï¼ˆä»localStorageæˆ–ä½¿ç”¨é»˜è®¤è§„åˆ™ï¼‰
            loadRules() {
                const saved = localStorage.getItem('documentClassificationRules');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.warn('Failed to parse saved rules, using default rules');
                    }
                }
                return JSON.parse(JSON.stringify(this.defaultRules));
            }

            // ä¿å­˜è§„åˆ™åˆ°localStorage
            saveRules() {
                localStorage.setItem('documentClassificationRules', JSON.stringify(this.customRules));
            }

            // è·å–å½“å‰è§„åˆ™
            getRules() {
                return this.customRules;
            }

            // æ£€æµ‹å…³é”®è¯å†²çª
            detectKeywordConflicts(targetCategory, keywords, excludeCategory = null) {
                const conflicts = [];
                const keywordSet = new Set(keywords.map(k => k.toLowerCase().trim()));
                
                for (const [category, categoryKeywords] of Object.entries(this.customRules)) {
                    // è·³è¿‡æ’é™¤çš„ç±»åˆ«ï¼ˆç”¨äºç¼–è¾‘æ—¶æ’é™¤è‡ªèº«ï¼‰
                    if (excludeCategory && category === excludeCategory) {
                        continue;
                    }
                    
                    // æ£€æŸ¥æ¯ä¸ªå…³é”®è¯æ˜¯å¦å†²çª
                    for (const keyword of keywordSet) {
                        for (const existingKeyword of categoryKeywords) {
                            const existing = existingKeyword.toLowerCase().trim();
                            
                            // å®Œå…¨é‡å¤
                            if (keyword === existing) {
                                conflicts.push({
                                    type: 'duplicate',
                                    keyword: keyword,
                                    conflictCategory: category,
                                    message: `å…³é”®è¯"${keyword}"å·²å­˜åœ¨äºç±»åˆ«"${category}"ä¸­`
                                });
                            }
                            // åŒ…å«å…³ç³»æ£€æµ‹
                            else if (keyword.includes(existing) || existing.includes(keyword)) {
                                conflicts.push({
                                    type: 'contains',
                                    keyword: keyword,
                                    conflictKeyword: existing,
                                    conflictCategory: category,
                                    message: `å…³é”®è¯"${keyword}"ä¸ç±»åˆ«"${category}"ä¸­çš„"${existing}"å­˜åœ¨åŒ…å«å…³ç³»`
                                });
                            }
                        }
                    }
                }
                
                return conflicts;
            }

            // è·å–å†²çªè§£å†³å»ºè®®
            getConflictResolutions(conflicts) {
                const resolutions = [];
                
                for (const conflict of conflicts) {
                    switch (conflict.type) {
                        case 'duplicate':
                            resolutions.push({
                                conflict: conflict,
                                options: [
                                    { 
                                        action: 'cancel', 
                                        description: 'å–æ¶ˆæ“ä½œï¼Œä¸æ·»åŠ é‡å¤å…³é”®è¯' 
                                    },
                                    { 
                                        action: 'remove_from_existing', 
                                        description: `ä»ç±»åˆ«"${conflict.conflictCategory}"ä¸­ç§»é™¤"${conflict.keyword}"` 
                                    }
                                ]
                            });
                            break;
                        case 'contains':
                            resolutions.push({
                                conflict: conflict,
                                options: [
                                    { 
                                        action: 'cancel', 
                                        description: 'å–æ¶ˆæ“ä½œï¼Œé¿å…æ­§ä¹‰' 
                                    },
                                    { 
                                        action: 'remove_from_existing', 
                                        description: `ä»ç±»åˆ«"${conflict.conflictCategory}"ä¸­ç§»é™¤"${conflict.conflictKeyword}"` 
                                    }
                                ]
                            });
                            break;
                    }
                }
                
                return resolutions;
            }

            // è§£å†³å†²çªï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
            resolveConflicts(conflicts, resolutions) {
                for (let i = 0; i < conflicts.length; i++) {
                    const conflict = conflicts[i];
                    const resolution = resolutions[i];
                    
                    if (resolution === 'remove_from_existing') {
                        // ä»ç°æœ‰ç±»åˆ«ä¸­ç§»é™¤å†²çªçš„å…³é”®è¯
                        const categoryKeywords = this.customRules[conflict.conflictCategory];
                        if (categoryKeywords) {
                            const keywordToRemove = conflict.type === 'duplicate' 
                                ? conflict.keyword 
                                : conflict.conflictKeyword;
                            
                            const index = categoryKeywords.findIndex(k => 
                                k.toLowerCase().trim() === keywordToRemove.toLowerCase()
                            );
                            
                            if (index > -1) {
                                categoryKeywords.splice(index, 1);
                                // å¦‚æœç±»åˆ«æ²¡æœ‰å…³é”®è¯äº†ï¼Œåˆ é™¤æ•´ä¸ªç±»åˆ«
                                if (categoryKeywords.length === 0) {
                                    delete this.customRules[conflict.conflictCategory];
                                }
                            }
                        }
                    } else if (resolution === 'cancel') {
                        return false; // å–æ¶ˆæ“ä½œ
                    }
                    // ignore æƒ…å†µä¸‹ä»€ä¹ˆéƒ½ä¸åšï¼Œç»§ç»­æ·»åŠ 
                }
                
                return true; // ç»§ç»­æ“ä½œ
            }

            // æ·»åŠ è§„åˆ™ï¼ˆå¸¦å†²çªæ£€æµ‹ï¼‰
            addRule(category, keywords) {
                if (!category || !keywords || keywords.length === 0) {
                    return { success: false, message: 'ç±»åˆ«åç§°å’Œå…³é”®è¯ä¸èƒ½ä¸ºç©º' };
                }

                // æ£€æµ‹å†²çª
                const conflicts = this.detectKeywordConflicts(category, keywords);
                
                if (conflicts.length > 0) {
                    return { 
                        success: false, 
                        conflicts: conflicts,
                        resolutions: this.getConflictResolutions(conflicts)
                    };
                }

                // æ— å†²çªï¼Œç›´æ¥æ·»åŠ 
                this.customRules[category] = keywords;
                this.saveRules();
                return { success: true };
            }

            // æ·»åŠ è§„åˆ™ï¼ˆå¤„ç†å†²çªåï¼‰
            addRuleWithResolution(category, keywords, conflictResolutions) {
                const conflicts = this.detectKeywordConflicts(category, keywords);
                
                if (!this.resolveConflicts(conflicts, conflictResolutions)) {
                    return { success: false, message: 'æ“ä½œå·²å–æ¶ˆ' };
                }

                this.customRules[category] = keywords;
                this.saveRules();
                return { success: true };
            }

            // æ›´æ–°è§„åˆ™ï¼ˆå¸¦å†²çªæ£€æµ‹ï¼‰
            updateRule(oldCategory, newCategory, keywords) {
                if (!newCategory || !keywords || keywords.length === 0) {
                    return { success: false, message: 'ç±»åˆ«åç§°å’Œå…³é”®è¯ä¸èƒ½ä¸ºç©º' };
                }

                if (oldCategory !== newCategory && this.customRules[newCategory]) {
                    return { success: false, message: 'ç±»åˆ«åç§°å·²å­˜åœ¨' };
                }

                // æ£€æµ‹å†²çªï¼ˆæ’é™¤è‡ªèº«ï¼‰
                const conflicts = this.detectKeywordConflicts(newCategory, keywords, oldCategory);
                
                if (conflicts.length > 0) {
                    return { 
                        success: false, 
                        conflicts: conflicts,
                        resolutions: this.getConflictResolutions(conflicts)
                    };
                }

                // æ— å†²çªï¼Œæ‰§è¡Œæ›´æ–°
                if (oldCategory !== newCategory) {
                    delete this.customRules[oldCategory];
                }
                this.customRules[newCategory] = keywords;
                this.saveRules();
                return { success: true };
            }

            // æ›´æ–°è§„åˆ™ï¼ˆå¤„ç†å†²çªåï¼‰
            updateRuleWithResolution(oldCategory, newCategory, keywords, conflictResolutions) {
                const conflicts = this.detectKeywordConflicts(newCategory, keywords, oldCategory);
                
                if (!this.resolveConflicts(conflicts, conflictResolutions)) {
                    return { success: false, message: 'æ“ä½œå·²å–æ¶ˆ' };
                }

                if (oldCategory !== newCategory) {
                    delete this.customRules[oldCategory];
                }
                this.customRules[newCategory] = keywords;
                this.saveRules();
                return { success: true };
            }

            // åˆ é™¤è§„åˆ™
            deleteRule(category) {
                if (this.customRules[category]) {
                    delete this.customRules[category];
                    this.saveRules();
                    return true;
                }
                return false;
            }

            // é‡ç½®ä¸ºé»˜è®¤è§„åˆ™
            resetToDefault() {
                this.customRules = JSON.parse(JSON.stringify(this.defaultRules));
                this.saveRules();
            }

            // å¯¼å‡ºè§„åˆ™
            exportRules() {
                return JSON.stringify(this.customRules, null, 2);
            }

            // å¯¼å…¥è§„åˆ™
            importRules(rulesJson) {
                try {
                    const rules = JSON.parse(rulesJson);
                    if (typeof rules === 'object' && rules !== null) {
                        this.customRules = rules;
                        this.saveRules();
                        return true;
                    }
                } catch (e) {
                    console.error('Failed to import rules:', e);
                }
                return false;
            }
        }

        // å…¨å±€è§„åˆ™ç®¡ç†å™¨å®ä¾‹
        const rulesManager = new CustomRulesManager();

        // é¢æ¿æ˜¾ç¤º/éšè—
        function toggleRulesPanel() {
            const panel = document.getElementById('rulesPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                renderRulesList();
            } else {
                panel.style.display = 'none';
            }
        }

        // æ¸²æŸ“è§„åˆ™åˆ—è¡¨ï¼ˆå¸¦å†²çªæç¤ºï¼‰
        function renderRulesList() {
            const container = document.getElementById('rulesList');
            const rules = rulesManager.getRules();
            
            if (Object.keys(rules).length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">æš‚æ— åˆ†ç±»è§„åˆ™</div>';
                return;
            }

            // æ£€æµ‹æ‰€æœ‰è§„åˆ™çš„å†²çª
            const allConflicts = {};
            for (const [category, keywords] of Object.entries(rules)) {
                const conflicts = rulesManager.detectKeywordConflicts(category, keywords, category);
                if (conflicts.length > 0) {
                    allConflicts[category] = conflicts;
                }
            }

            const html = Object.entries(rules).map(([category, keywords]) => {
                const hasConflicts = allConflicts[category] && allConflicts[category].length > 0;
                const conflictIcon = hasConflicts ? 'âš ï¸' : '';
                const conflictStyle = hasConflicts ? 'border-color: var(--warning-color);' : '';
                
                // æ ‡è®°æœ‰å†²çªçš„å…³é”®è¯
                const keywordHtml = keywords.map(keyword => {
                    const isConflicted = hasConflicts && allConflicts[category].some(c => 
                        c.keyword === keyword.toLowerCase() || c.conflictKeyword === keyword.toLowerCase()
                    );
                    
                    if (isConflicted) {
                        return `<span style="color: var(--warning-color); font-weight: bold;" title="æ­¤å…³é”®è¯å­˜åœ¨å†²çª">${keyword}</span>`;
                    }
                    return keyword;
                }).join(', ');

                return `
                    <div style="
                        display: flex; 
                        align-items: center; 
                        gap: 10px; 
                        padding: 10px; 
                        background-color: var(--bg-secondary); 
                        border: 1px solid var(--border-color); 
                        border-radius: var(--border-radius);
                        ${conflictStyle}
                    ">
                        <div style="flex: 1; min-width: 100px;">
                            <input type="text" value="${category}" 
                                   onblur="updateRuleCategoryName(this, '${category}')"
                                   onkeydown="if(event.key==='Enter') this.blur()"
                                   class="form-control" 
                                   style="height: 32px; font-weight: bold; color: var(--accent-color); background-color: var(--bg-secondary); border: 1px solid var(--border-color); padding: 4px 8px; border-radius: var(--border-radius);">
                            ${hasConflicts ? '<div style="font-size: 12px; color: var(--warning-color); margin-top: 2px;">å­˜åœ¨å…³é”®è¯å†²çª</div>' : ''}
                        </div>
                        <div style="flex: 3; font-size: 14px; color: var(--text-secondary);">
                            <input type="text" value="${keywords.join(', ')}" 
                                   onblur="updateRuleKeywords(this, '${category}')"
                                   onkeydown="if(event.key==='Enter') this.blur()"
                                   class="form-control" 
                                   style="height: 32px; background-color: var(--bg-secondary); border: 1px solid var(--border-color); padding: 4px 8px; border-radius: var(--border-radius); color: var(--text-primary);">
                        </div>
                        <div style="display: flex; gap: 5px;">
                            ${hasConflicts ? `
                                <button onclick="showCategoryConflicts('${category}')" class="tool-button" style="padding: 6px 12px; font-size: 12px; background-color: var(--warning-color); color: white; border-color: var(--warning-color);">
                                    <span>âš ï¸</span>
                                    æŸ¥çœ‹å†²çª
                                </button>
                            ` : ''}
                            <button onclick="deleteRule('${category}')" class="tool-button danger" style="padding: 6px 12px; font-size: 12px;">
                                <span>ğŸ—‘ï¸</span>
                                åˆ é™¤
                            </button>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;

            // å¦‚æœæœ‰å†²çªï¼Œåœ¨åˆ—è¡¨é¡¶éƒ¨æ˜¾ç¤ºæ€»ä½“æç¤º
            if (Object.keys(allConflicts).length > 0) {
                const conflictSummary = document.createElement('div');
                conflictSummary.style.cssText = `
                    background-color: #fff3cd;
                    border: 1px solid var(--warning-color);
                    border-radius: var(--border-radius);
                    padding: 12px;
                    margin-bottom: 10px;
                    color: #856404;
                    font-size: 14px;
                `;
                
                const conflictCount = Object.values(allConflicts).reduce((total, conflicts) => total + conflicts.length, 0);
                conflictSummary.innerHTML = `
                    <strong>âš ï¸ æ£€æµ‹åˆ° ${conflictCount} ä¸ªå…³é”®è¯å†²çª</strong><br>
                    <small>å†²çªçš„å…³é”®è¯å¯èƒ½å¯¼è‡´åˆ†ç±»ç»“æœä¸å‡†ç¡®ï¼Œå»ºè®®åŠæ—¶å¤„ç†ã€‚</small>
                `;
                
                container.insertBefore(conflictSummary, container.firstChild);
            }
        }

        // æ˜¾ç¤ºç‰¹å®šç±»åˆ«çš„å†²çªè¯¦æƒ…
        function showCategoryConflicts(category) {
            const rules = rulesManager.getRules();
            const conflicts = rulesManager.detectKeywordConflicts(category, rules[category], category);
            
            if (conflicts.length === 0) {
                ToastManager.success('è¯¥ç±»åˆ«æ²¡æœ‰å†²çª');
                return;
            }
            
            let message = `ç±»åˆ«"${category}"çš„å†²çªè¯¦æƒ…ï¼š\n\n`;
            for (let i = 0; i < conflicts.length; i++) {
                message += `${i + 1}. ${conflicts[i].message}\n`;
            }
            
            message += '\næ˜¯å¦è¦è‡ªåŠ¨è§£å†³è¿™äº›å†²çªï¼Ÿ';
            
            if (confirm(message)) {
                // è‡ªåŠ¨è§£å†³å†²çª - é»˜è®¤é€‰æ‹©ç§»é™¤ç°æœ‰å†²çªå…³é”®è¯
                const resolutions = conflicts.map(() => 'remove_from_existing');
                const result = rulesManager.updateRuleWithResolution(category, category, rules[category], resolutions);
                
                if (result.success) {
                    renderRulesList();
                    ToastManager.success('å†²çªå·²è‡ªåŠ¨è§£å†³');
                } else {
                    ToastManager.error(result.message || 'è‡ªåŠ¨è§£å†³å†²çªå¤±è´¥');
                }
            }
        }

        // æ˜¾ç¤ºå†²çªè§£å†³å¯¹è¯æ¡†
        function showConflictResolutionDialog(conflicts, resolutions, callback) {
            const resolutionChoices = [];
            let dialogContent = 'æ£€æµ‹åˆ°å…³é”®è¯å†²çªï¼š\n\n';
            
            for (let i = 0; i < conflicts.length; i++) {
                const conflict = conflicts[i];
                const options = resolutions[i].options;
                
                dialogContent += `å†²çª ${i + 1}: ${conflict.message}\n`;
                dialogContent += 'è§£å†³æ–¹æ¡ˆï¼š\n';
                
                for (let j = 0; j < options.length; j++) {
                    dialogContent += `  ${j + 1}. ${options[j].description}\n`;
                }
                
                const choice = prompt(dialogContent + `\nè¯·é€‰æ‹©è§£å†³æ–¹æ¡ˆ (1-${options.length}):`);
                const choiceNum = parseInt(choice);
                
                if (!choice || isNaN(choiceNum) || choiceNum < 1 || choiceNum > options.length) {
                    ToastManager.error('æ“ä½œå·²å–æ¶ˆ');
                    return;
                }
                
                resolutionChoices.push(options[choiceNum - 1].action);
                dialogContent = ''; // æ¸…ç©ºï¼Œç»§ç»­ä¸‹ä¸€ä¸ªå†²çª
            }
            
            callback(resolutionChoices);
        }

        // æ·»åŠ è‡ªå®šä¹‰è§„åˆ™ï¼ˆå¸¦å†²çªæ£€æµ‹ï¼‰
        function addCustomRule() {
            const categoryInput = document.getElementById('newCategory');
            const keywordsInput = document.getElementById('newKeywords');
            
            const category = categoryInput.value.trim();
            const keywordsStr = keywordsInput.value.trim();
            
            if (!category || !keywordsStr) {
                ToastManager.error('è¯·å¡«å†™ç±»åˆ«åç§°å’Œå…³é”®è¯');
                return;
            }
            
            const keywords = keywordsStr.split(',').map(k => k.trim()).filter(k => k.length > 0);
            
            if (keywords.length === 0) {
                ToastManager.error('è¯·è‡³å°‘è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆå…³é”®è¯');
                return;
            }
            
            // å°è¯•æ·»åŠ è§„åˆ™
            const result = rulesManager.addRule(category, keywords);
            
            if (result.success) {
                // æˆåŠŸæ·»åŠ 
                categoryInput.value = '';
                keywordsInput.value = '';
                renderRulesList();
                ToastManager.success(`å·²æ·»åŠ åˆ†ç±»è§„åˆ™ï¼š${category}`);
            } else if (result.conflicts) {
                // æœ‰å†²çªï¼Œæ˜¾ç¤ºè§£å†³æ–¹æ¡ˆ
                showConflictResolutionDialog(result.conflicts, result.resolutions, (resolutionChoices) => {
                    const finalResult = rulesManager.addRuleWithResolution(category, keywords, resolutionChoices);
                    
                    if (finalResult.success) {
                        categoryInput.value = '';
                        keywordsInput.value = '';
                        renderRulesList();
                        ToastManager.success(`å·²æ·»åŠ åˆ†ç±»è§„åˆ™ï¼š${category}`);
                    } else {
                        ToastManager.error(finalResult.message || 'æ·»åŠ è§„åˆ™å¤±è´¥');
                    }
                });
            } else {
                ToastManager.error(result.message || 'æ·»åŠ è§„åˆ™å¤±è´¥');
            }
        }

        // æ›´æ–°ç±»åˆ«åç§°ï¼ˆç›´æ¥ç¼–è¾‘ï¼‰
        function updateRuleCategoryName(input, oldCategory) {
            const newCategory = input.value.trim();
            const rules = rulesManager.getRules();
            
            if (!newCategory) {
                ToastManager.error('ç±»åˆ«åç§°ä¸èƒ½ä¸ºç©º');
                input.value = oldCategory; // æ¢å¤åŸå€¼
                return;
            }
            
            if (newCategory === oldCategory) {
                return; // æ²¡æœ‰å˜åŒ–
            }
            
            if (rules[newCategory]) {
                ToastManager.error('ç±»åˆ«åç§°å·²å­˜åœ¨');
                input.value = oldCategory; // æ¢å¤åŸå€¼
                return;
            }
            
            const keywords = rules[oldCategory];
            const result = rulesManager.updateRule(oldCategory, newCategory, keywords);
            
            if (result.success) {
                renderRulesList();
                ToastManager.success(`ç±»åˆ«åç§°å·²æ›´æ–°ä¸ºï¼š${newCategory}`);
            } else if (result.conflicts) {
                showConflictResolutionDialog(result.conflicts, result.resolutions, (resolutionChoices) => {
                    const finalResult = rulesManager.updateRuleWithResolution(oldCategory, newCategory, keywords, resolutionChoices);
                    
                    if (finalResult.success) {
                        renderRulesList();
                        ToastManager.success(`ç±»åˆ«åç§°å·²æ›´æ–°ä¸ºï¼š${newCategory}`);
                    } else {
                        input.value = oldCategory; // æ¢å¤åŸå€¼
                        ToastManager.error(finalResult.message || 'æ›´æ–°å¤±è´¥');
                    }
                });
            } else {
                input.value = oldCategory; // æ¢å¤åŸå€¼
                ToastManager.error(result.message || 'æ›´æ–°å¤±è´¥');
            }
        }

        // æ›´æ–°å…³é”®è¯ï¼ˆç›´æ¥ç¼–è¾‘ï¼‰
        function updateRuleKeywords(input, category) {
            const keywordsStr = input.value.trim();
            const rules = rulesManager.getRules();
            const originalKeywords = rules[category];
            
            if (!keywordsStr) {
                ToastManager.error('å…³é”®è¯ä¸èƒ½ä¸ºç©º');
                input.value = originalKeywords.join(', '); // æ¢å¤åŸå€¼
                return;
            }
            
            const newKeywords = keywordsStr.split(',').map(k => k.trim()).filter(k => k.length > 0);
            
            if (newKeywords.length === 0) {
                ToastManager.error('è¯·è‡³å°‘è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆå…³é”®è¯');
                input.value = originalKeywords.join(', '); // æ¢å¤åŸå€¼
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
            if (JSON.stringify(newKeywords.sort()) === JSON.stringify(originalKeywords.sort())) {
                return; // æ²¡æœ‰å˜åŒ–
            }
            
            const result = rulesManager.updateRule(category, category, newKeywords);
            
            if (result.success) {
                renderRulesList();
                ToastManager.success(`å…³é”®è¯å·²æ›´æ–°`);
            } else if (result.conflicts) {
                showConflictResolutionDialog(result.conflicts, result.resolutions, (resolutionChoices) => {
                    const finalResult = rulesManager.updateRuleWithResolution(category, category, newKeywords, resolutionChoices);
                    
                    if (finalResult.success) {
                        renderRulesList();
                        ToastManager.success(`å…³é”®è¯å·²æ›´æ–°`);
                    } else {
                        input.value = originalKeywords.join(', '); // æ¢å¤åŸå€¼
                        ToastManager.error(finalResult.message || 'æ›´æ–°å¤±è´¥');
                    }
                });
            } else {
                input.value = originalKeywords.join(', '); // æ¢å¤åŸå€¼
                ToastManager.error(result.message || 'æ›´æ–°å¤±è´¥');
            }
        }

        // ç¼–è¾‘è§„åˆ™ï¼ˆå¸¦å†²çªæ£€æµ‹ï¼‰
        function editRule(category) {
            const rules = rulesManager.getRules();
            const keywords = rules[category];
            
            const newCategory = prompt('ç±»åˆ«åç§°:', category);
            if (newCategory === null) return; // ç”¨æˆ·å–æ¶ˆ
            
            const newKeywordsStr = prompt('å…³é”®è¯ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰:', keywords.join(', '));
            if (newKeywordsStr === null) return; // ç”¨æˆ·å–æ¶ˆ
            
            const newKeywords = newKeywordsStr.split(',').map(k => k.trim()).filter(k => k.length > 0);
            
            if (!newCategory.trim() || newKeywords.length === 0) {
                ToastManager.error('ç±»åˆ«åç§°å’Œå…³é”®è¯ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            // å°è¯•æ›´æ–°è§„åˆ™
            const result = rulesManager.updateRule(category, newCategory.trim(), newKeywords);
            
            if (result.success) {
                // æˆåŠŸæ›´æ–°
                renderRulesList();
                ToastManager.success(`å·²æ›´æ–°åˆ†ç±»è§„åˆ™ï¼š${newCategory.trim()}`);
            } else if (result.conflicts) {
                // æœ‰å†²çªï¼Œæ˜¾ç¤ºè§£å†³æ–¹æ¡ˆ
                showConflictResolutionDialog(result.conflicts, result.resolutions, (resolutionChoices) => {
                    const finalResult = rulesManager.updateRuleWithResolution(category, newCategory.trim(), newKeywords, resolutionChoices);
                    
                    if (finalResult.success) {
                        renderRulesList();
                        ToastManager.success(`å·²æ›´æ–°åˆ†ç±»è§„åˆ™ï¼š${newCategory.trim()}`);
                    } else {
                        ToastManager.error(finalResult.message || 'æ›´æ–°è§„åˆ™å¤±è´¥');
                    }
                });
            } else {
                ToastManager.error(result.message || 'æ›´æ–°è§„åˆ™å¤±è´¥');
            }
        }

        // åˆ é™¤è§„åˆ™
        function deleteRule(category) {
            if (confirm(`ç¡®å®šè¦åˆ é™¤åˆ†ç±»è§„åˆ™"${category}"å—ï¼Ÿ`)) {
                if (rulesManager.deleteRule(category)) {
                    renderRulesList();
                    ToastManager.success(`å·²åˆ é™¤åˆ†ç±»è§„åˆ™ï¼š${category}`);
                } else {
                    ToastManager.error('åˆ é™¤è§„åˆ™å¤±è´¥');
                }
            }
        }

        // é‡ç½®ä¸ºé»˜è®¤è§„åˆ™
        function resetToDefault() {
            if (confirm('ç¡®å®šè¦é‡ç½®ä¸ºé»˜è®¤åˆ†ç±»è§„åˆ™å—ï¼Ÿè¿™å°†æ¸…é™¤æ‰€æœ‰è‡ªå®šä¹‰è§„åˆ™ã€‚')) {
                rulesManager.resetToDefault();
                renderRulesList();
                ToastManager.success('å·²é‡ç½®ä¸ºé»˜è®¤åˆ†ç±»è§„åˆ™');
            }
        }

        // å¯¼å‡ºè§„åˆ™
        function exportRules() {
            const rulesJson = rulesManager.exportRules();
            Utils.downloadTextFile(rulesJson, 'classification_rules.json', 'application/json');
            ToastManager.success('åˆ†ç±»è§„åˆ™å·²å¯¼å‡º');
        }

        // å¯¼å…¥è§„åˆ™
        function importRules(fileInput) {
            const file = fileInput.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    if (rulesManager.importRules(e.target.result)) {
                        renderRulesList();
                        ToastManager.success('åˆ†ç±»è§„åˆ™å¯¼å…¥æˆåŠŸ');
                    } else {
                        ToastManager.error('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                    }
                } catch (error) {
                    ToastManager.error('å¯¼å…¥å¤±è´¥ï¼š' + error.message);
                }
                fileInput.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
            };
            reader.readAsText(file);
        }

        // åŸæœ‰åŠŸèƒ½ä»£ç 
        function processDocument() {
            const input = document.getElementById('input').value.trim();
            if (!input) {
                ToastManager.error('è¯·å…ˆè¾“å…¥æ–‡æ¡£å†…å®¹');
                return;
            }

            try {
                const result = processFunctionDocuments(input);
                document.getElementById('output').value = result.output;
                updateStats(result.stats);
                ToastManager.success('æ–‡æ¡£å¤„ç†å®Œæˆï¼');
            } catch (error) {
                ToastManager.error('å¤„ç†å¤±è´¥ï¼š' + error.message);
            }
        }

        // å…³é”®è¯æ˜ å°„è¡¨ï¼Œç”¨äºåˆå¹¶ç›¸ä¼¼ç±»åˆ«
        function createKeywordMap(categories) {
            const keywordMap = {};
            const categoryKeys = Object.keys(categories);
            
            for (let i = 0; i < categoryKeys.length; i++) {
                const category1 = categoryKeys[i];
                let mergeTarget = category1;
                
                // æŸ¥æ‰¾æ˜¯å¦æœ‰å…¶ä»–ç±»åˆ«æ˜¯å½“å‰ç±»åˆ«çš„å­é›†
                for (let j = 0; j < categoryKeys.length; j++) {
                    if (i !== j) {
                        const category2 = categoryKeys[j];
                        // å¦‚æœcategory1åŒ…å«category2ï¼Œåˆ™å°†category2åˆå¹¶åˆ°category1
                        if (category1.includes(category2) && category2.length < category1.length) {
                            mergeTarget = category2;
                            break;
                        }
                        // å¦‚æœcategory2åŒ…å«category1ï¼Œåˆ™å°†category1åˆå¹¶åˆ°category2
                        else if (category2.includes(category1) && category1.length < category2.length) {
                            mergeTarget = category2;
                            break;
                        }
                    }
                }
                keywordMap[category1] = mergeTarget;
            }
            
            return keywordMap;
        }

        // ä»æ–‡æœ¬ä¸­æå–å…³é”®è¯è¿›è¡Œåˆ†ç±»ï¼ˆä½¿ç”¨è‡ªå®šä¹‰è§„åˆ™ï¼‰
        function extractKeywordsFromText(text) {
            const keywordPatterns = rulesManager.getRules();
            const textLower = text.toLowerCase();
            
            // æŸ¥æ‰¾åŒ¹é…çš„å…³é”®è¯
            for (const [category, patterns] of Object.entries(keywordPatterns)) {
                for (const pattern of patterns) {
                    if (textLower.includes(pattern.toLowerCase())) {
                        return category;
                    }
                }
            }
            
            return null;
        }

        function processFunctionDocuments(content) {
            // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…åŠŸèƒ½å•æ®
            const pattern = /ã€(.*?)ã€‘([^\n]+)/g;
            const matches = [];
            let match;
            
            while ((match = pattern.exec(content)) !== null) {
                matches.push({
                    category: match[1].trim(),
                    functionName: match[2].trim()
                });
            }

            // æŒ‰ç±»åˆ«åˆ†ç±»
            const categories = {};
            
            // å¤„ç†æœ‰ã€ã€‘ç¬¦å·çš„åŠŸèƒ½å•æ®
            matches.forEach(({ category, functionName }) => {
                if (!categories[category]) {
                    categories[category] = [];
                }
                categories[category].push(functionName);
            });

            // åˆ›å»ºå…³é”®è¯æ˜ å°„è¿›è¡Œç±»åˆ«åˆå¹¶
            const keywordMap = createKeywordMap(categories);
            const mergedCategories = {};
            
            // åˆå¹¶ç›¸ä¼¼ç±»åˆ«
            Object.entries(categories).forEach(([category, functions]) => {
                const targetCategory = keywordMap[category];
                if (!mergedCategories[targetCategory]) {
                    mergedCategories[targetCategory] = [];
                }
                mergedCategories[targetCategory] = mergedCategories[targetCategory].concat(functions);
            });

            // æå–æ²¡æœ‰ã€ã€‘ç¬¦å·çš„è¡Œå¹¶å°è¯•è‡ªåŠ¨åˆ†ç±»
            const lines = content.split('\n');
            const unclassifiedFunctions = [];
            
            lines.forEach(line => {
                line = line.trim();
                if (line && !line.match(/ã€.*?ã€‘/)) {
                    // æ£€æŸ¥æ˜¯å¦å·²ç»è¢«åŒ¹é…è¿‡ï¼ˆé¿å…é‡å¤ï¼‰
                    const isMatched = matches.some(({ functionName }) => 
                        line === functionName.trim()
                    );
                    if (!isMatched) {
                        // å°è¯•åŸºäºå…³é”®è¯è‡ªåŠ¨åˆ†ç±»
                        const detectedCategory = extractKeywordsFromText(line);
                        if (detectedCategory) {
                            if (!mergedCategories[detectedCategory]) {
                                mergedCategories[detectedCategory] = [];
                            }
                            mergedCategories[detectedCategory].push(line);
                        } else {
                            unclassifiedFunctions.push(line);
                        }
                    }
                }
            });

            // æ·»åŠ æœªèƒ½åˆ†ç±»çš„åŠŸèƒ½åˆ°"å…¶ä»–"ç±»åˆ«
            if (unclassifiedFunctions.length > 0) {
                mergedCategories['å…¶ä»–'] = unclassifiedFunctions;
            }

            // ç”Ÿæˆæ ¼å¼åŒ–è¾“å‡º
            const outputLines = [];
            let totalFunctions = 0;
            let categorizedFunctions = 0;

            Object.entries(mergedCategories).forEach(([category, functions]) => {
                // æ·»åŠ ç±»åˆ«æ ‡é¢˜
                outputLines.push(`${category}åŠå…¶å­åŠŸèƒ½å•æ®${functions.length}ä¸ª`);
                
                // æ·»åŠ åºå·åŠŸèƒ½åˆ—è¡¨
                functions.forEach((func, index) => {
                    if (category === 'å…¶ä»–') {
                        outputLines.push(` ${index + 1}ã€${func}`);
                    } else {
                        outputLines.push(` ${index + 1}ã€ã€${category}ã€‘${func}`);
                        categorizedFunctions++;
                    }
                });
                
                // æ·»åŠ ç©ºè¡Œåˆ†éš”
                outputLines.push('');
                totalFunctions += functions.length;
            });

            // ç§»é™¤æœ€åçš„ç©ºè¡Œ
            if (outputLines.length > 0 && outputLines[outputLines.length - 1] === '') {
                outputLines.pop();
            }

            const stats = {
                totalCategories: Object.keys(mergedCategories).length,
                totalFunctions: totalFunctions,
                categorizedFunctions: categorizedFunctions,
                otherFunctions: unclassifiedFunctions.length
            };

            return {
                output: outputLines.join('\n'),
                stats: stats
            };
        }

        function updateStats(stats) {
            document.getElementById('totalCategories').textContent = stats.totalCategories;
            document.getElementById('totalFunctions').textContent = stats.totalFunctions;
            document.getElementById('categorizedFunctions').textContent = stats.categorizedFunctions;
            document.getElementById('otherFunctions').textContent = stats.otherFunctions;
            document.getElementById('stats').style.display = 'block';
        }

        function clearAll() {
            document.getElementById('input').value = '';
            document.getElementById('output').value = '';
            document.getElementById('stats').style.display = 'none';
            ToastManager.success('å·²æ¸…ç©ºæ‰€æœ‰å†…å®¹');
        }

        async function copyResult() {
            const output = document.getElementById('output').value;
            if (!output) {
                ToastManager.error('æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹');
                return;
            }

            const success = await Utils.copyToClipboard(output);
            if (success) {
                ToastManager.success('ç»“æœå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
            } else {
                ToastManager.error('å¤åˆ¶å¤±è´¥');
            }
        }

// ç¤ºä¾‹æ•°æ®åŠ è½½
        function loadExample() {
            const exampleData = `ã€GMã€‘PVETestå…³å¡é€‰æ‹©ï¼Œéœ€è¦æ”¯æŒè¯»å–pve_section_config
ã€è‹±é›„è£…å¤‡ã€‘æ›¿æ¢è£…å¤‡çš„æ—¶å€™éœ€è¦æ”¯æŒè„±ä¸‹åç©¿æˆ´
ã€è‹±é›„è£…å¤‡ã€‘æ›¿æ¢æ­£åœ¨è¢«å…¶ä»–è‹±é›„ç©¿æˆ´çš„è£…å¤‡æ—¶å…ˆå¼¹å‡ºå¯¹æ¯”ç•Œé¢ç„¶åç›´æ¥æ›¿æ¢
ã€è‹±é›„éƒ¨é˜Ÿã€‘è‹±é›„é˜Ÿä¼ç®¡ç†åŠŸèƒ½
ã€è‹±é›„ã€‘è§’è‰²å±æ€§ä¼˜åŒ–
ã€æ¼”ä¹ å®¤ã€‘é˜²å®ˆé˜µå®¹æ¨èè®¾ç½®ä¼˜åŒ–-é¢„åˆ¶
ã€æ¼”ä¹ å®¤ã€‘é˜²å®ˆé˜µå®¹æ¨èè®¾ç½®ä¼˜åŒ–-UI-æ¨èå›¾æ ‡å’Œä½ç½®
pvebosså…³æˆ˜åŠ›æ¨èæŒ‘æˆ˜ï¼Œpveå…³å¡å¡ç‚¹å…·ä½“åˆ°æ¯ä¸ªboss
æ‰“é‡æ€ªé‡ä¼¤ç‡æå‡åˆ°åƒåˆ†ä¹‹1
ã€GMã€‘å®¢æˆ·ç«¯å¢åŠ åè®®å½•åˆ¶ã€å›æ”¾çš„åŠŸèƒ½
pveå¤±è´¥æ¨èï¼Œå»ºç­‘å‡çº§å‰äº”ç« æ”¾åˆ°ç¬¬ä¸€ä½
è£…å¤‡å¼ºåŒ–ç³»ç»Ÿä¼˜åŒ–
æ­¦å™¨å‡çº§ç•Œé¢æ”¹è¿›`;
            
            document.getElementById('input').value = exampleData;
        }
    </script>
</body>
</html>